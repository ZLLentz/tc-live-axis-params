VAR_INPUT
	bExecute: BOOL;
	bReset: BOOL;
	stDriveRef: ST_DriveRef;
END_VAR
VAR_IN_OUT
	stConfig: ST_AxisParams;
	Axis: AXIS_REF;
END_VAR
VAR_OUTPUT
	bBusy: BOOL;
	bError: BOOL;
	iAdsErrId: UINT;
	iCANopenErrId: UINT;
END_VAR
VAR
	iCycles: INT := 0;
	bReadOk: BOOL := FALSE;
	bInnerExec: BOOL := FALSE;
{% for item in coe_params %}
	{{ item.fb_name }}: FB_CoERead_ByDriveRef;
	{{ item.nindex }}: WORD;
{% endfor %}
END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[// File auto-generated! Take care editing!
// Clears errors and allows a new read
IF bReset THEN
	bExecute := FALSE;
	bReset := FALSE;
END_IF
// Fails in the first n cycles depending on terminals, wait a bit
IF NOT bReadOk THEN
	iCycles := iCycles + 1;
	IF iCycles > 100 THEN
		bReadOk := TRUE;
	END_IF
END_IF
bInnerExec := bExecute AND bReadOk;
{% for item in coe_params %}
{% if item.multi_channel %}
CASE stDriveRef.DriveNo OF
{% for index in item.index %}
	{{ loop.index0 }}:
		{{ item.nindex }} := {{ index }};
{% endfor %}
END_CASE
{% else %}
{{ item.nindex }} := {{ item.index }};
{% endif %}
{{ item.fb_read }}(bExecute:=bInnerExec,
	stDriveRef:=stDriveRef,
	nindex:={{ item.nindex }},
	nSubIndex:={{ item.subindex }},
	pDstBuf:=ADR(stConfig.{{ item.stConfig }}),
	cbBufLen:=SIZEOF(stConfig.{{ item.stConfig }}));
{% endfor %}
]]></ST>
    </Implementation>
